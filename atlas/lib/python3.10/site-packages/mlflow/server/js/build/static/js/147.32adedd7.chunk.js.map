{"version":3,"file":"static/js/147.32adedd7.chunk.js","mappings":"oHAEA,MAAMA,GAAAA,EACGC,eAAiB,CACtBC,eAAgB,iBAChBC,YAAa,cACbC,cAAe,gBACfC,aAAc,gBAIlB,K,uECRA,MAAMC,GAAuBC,EAAAA,EAAAA,eAAc,MAErCC,EAAe,CACnBC,UAAU,EACVC,MAAO,MAET,MAAMC,UAAsBC,EAAAA,UAC1BC,WAAAA,CAAYC,GACVC,MAAMD,GACNE,KAAKC,mBAAqBD,KAAKC,mBAAmBC,KAAKF,MACvDA,KAAKG,MAAQX,CACf,CACA,+BAAOY,CAAyBV,GAC9B,MAAO,CACLD,UAAU,EACVC,QAEJ,CACAO,kBAAAA,GACE,MAAM,MACJP,GACEM,KAAKG,MACT,GAAc,OAAVT,EAAgB,CAElB,IADA,IAAIW,EAAqBC,EAChBC,EAAOC,UAAUC,OAAQC,EAAO,IAAIC,MAAMJ,GAAOK,EAAO,EAAGA,EAAOL,EAAMK,IAC/EF,EAAKE,GAAQJ,UAAUI,GAEsC,QAA9DP,GAAuBC,EAAcN,KAAKF,OAAOe,eAA6C,IAAxBR,GAA0CA,EAAoBS,KAAKR,EAAa,CACrJI,OACAK,OAAQ,mBAEVf,KAAKgB,SAASxB,EAChB,CACF,CACAyB,iBAAAA,CAAkBvB,EAAOwB,GACvB,IAAIC,EAAqBC,EACuC,QAA/DD,GAAuBC,EAAepB,KAAKF,OAAOuB,eAA6C,IAAxBF,GAA0CA,EAAoBL,KAAKM,EAAc1B,EAAOwB,EAClK,CACAI,kBAAAA,CAAmBC,EAAWC,GAC5B,MAAM,SACJ/B,GACEO,KAAKG,OACH,UACJsB,GACEzB,KAAKF,MAQP,IAAI4B,EAAsBC,EADxBlC,GAAgC,OAApB+B,EAAU9B,OA8C9B,WACE,IAAIkC,EAAIpB,UAAUC,OAAS,QAAsBoB,IAAjBrB,UAAU,GAAmBA,UAAU,GAAK,GACxEsB,EAAItB,UAAUC,OAAS,QAAsBoB,IAAjBrB,UAAU,GAAmBA,UAAU,GAAK,GAC5E,OAAOoB,EAAEnB,SAAWqB,EAAErB,QAAUmB,EAAEG,MAAK,CAACC,EAAMC,KAAWC,OAAOC,GAAGH,EAAMF,EAAEG,KAC7E,CAlDgDG,CAAgBb,EAAUE,UAAWA,KAEd,QAAhEC,GAAwBC,EAAe3B,KAAKF,OAAOe,eAA8C,IAAzBa,GAA2CA,EAAqBZ,KAAKa,EAAc,CAC1JU,KAAMZ,EACNa,KAAMf,EAAUE,UAChBV,OAAQ,SAEVf,KAAKgB,SAASxB,GAElB,CACA+C,MAAAA,GACE,MAAM,SACJC,EAAQ,eACRC,EAAc,kBACdC,EAAiB,SACjBC,GACE3C,KAAKF,OACH,SACJL,EAAQ,MACRC,GACEM,KAAKG,MACT,IAAIyC,EAAgBJ,EACpB,GAAI/C,EAAU,CACZ,MAAMK,EAAQ,CACZJ,QACAO,mBAAoBD,KAAKC,oBAE3B,GAA8B,oBAAnBwC,EACTG,EAAgBH,EAAe3C,QAC1B,GAAI4C,EACTE,GAAgBC,EAAAA,EAAAA,eAAcH,EAAmB5C,OAC5C,IAAiB,OAAb6C,KAAqBG,EAAAA,EAAAA,gBAAeH,GAG7C,MAAMjD,EAFNkD,EAAgBD,CAGlB,CACF,CACA,OAAOE,EAAAA,EAAAA,eAAcvD,EAAqByD,SAAU,CAClDC,MAAO,CACLvD,WACAC,QACAO,mBAAoBD,KAAKC,qBAE1B2C,EACL,E,8CCxFF,SAASK,IACP,OACEC,EAAAA,EAAAA,GAACC,EAAAA,IAAK,CACJ,cAAY,WACZC,OAAOF,EAAAA,EAAAA,GAACG,EAAAA,EAAgB,CAAAC,GAAA,SAACC,eAAe,UACxCC,aACEN,EAAAA,EAAAA,GAACG,EAAAA,EAAgB,CAAAC,GAAA,SACfC,eAAe,sDAInBE,OAAOP,EAAAA,EAAAA,GAACQ,EAAAA,EAAU,KAGxB,CAEO,SAASC,EAAmBC,GAA6D,IAA5D,SAAEpB,GAAuDoB,EAK3F,OACEV,EAAAA,EAAAA,GAACvD,EAAa,CAAC0B,QALjB,SAA2B3B,EAAcwB,GACvC2C,QAAQnE,MAAM,4BAA6BA,EAAOwB,EAAK4C,eACzD,EAG6CnB,UAAUO,EAAAA,EAAAA,GAACD,EAAa,IAAIT,SACpEA,GAGP,CAEO,SAASuB,EACdC,EACApE,EACAqE,GAEA,OAAO,SAAoCnE,GACzC,OACEoD,EAAAA,EAAAA,GAACS,EAAmB,CAAAnB,UAElBU,EAAAA,EAAAA,GAACtD,EAAS,IAAKE,KAGrB,CACF,C,yFC7BO,MAAMoE,EAC6BtE,GAEtCE,IASA,MAAMqE,GAAWC,EAAAA,EAAAA,MACXC,GAAWC,EAAAA,EAAAA,MACXC,GAASC,EAAAA,EAAAA,KAEf,OACEtB,EAAAA,EAAAA,GAACtD,EACC,CACA2E,OAAQA,EACRJ,SAAUA,EACVE,SAAUA,KACLvE,GACL,C,sPC/BD,MAAM2E,EAAqB3E,IAChC,MAAM,QAAE4E,IAAYF,EAAAA,EAAAA,MACb9E,EAAOiF,IAAYC,EAAAA,EAAAA,YACpBP,GAAWC,EAAAA,EAAAA,MAEXO,GAAWC,EAAAA,EAAAA,MA4BjB,OAzBAC,EAAAA,EAAAA,YAAU,KACRJ,OAAS9C,EAAU,GAClB,CAAC6C,KAEJK,EAAAA,EAAAA,YAAU,KAER,IAAKjF,EAAMkF,SAAWN,EAAS,CAC7B,MAAMO,GAASC,EAAAA,EAAAA,IAAUR,GACzBO,EAAOE,QAAQC,OAAOC,IACpBC,EAAAA,EAAMC,sBAAsBF,GAC5BV,EAASU,EAAE,IAEbR,EAASI,EACX,IACC,CAACJ,EAAUH,EAAS5E,EAAMkF,WAE7BD,EAAAA,EAAAA,YAAU,KAAO,IAADS,EACG,QAAjBA,EAAI1F,EAAMkF,eAAO,IAAAQ,GAAbA,EAAeC,cACjBpB,EAASqB,EAAAA,EAAOC,gBAAgB7F,EAAMkF,QAAQS,aAAc3F,EAAMkF,QAAQN,SAAU,CAClFkB,SAAS,GAEb,GACC,CAACvB,EAAUvE,EAAMkF,UAGE,OAAb,OAALtF,QAAK,IAALA,OAAK,EAALA,EAAOmG,SACF3C,EAAAA,EAAAA,GAAC4C,EAAAA,EAAgB,KAKxB5C,EAAAA,EAAAA,GAAC6C,EAAAA,IAAW,CAAAvD,UACVU,EAAAA,EAAAA,GAAC8C,EAAAA,IAAc,KACH,EAIZC,GAA0B/B,EAAAA,EAAAA,IAC9BgC,EAAAA,EAAAA,KAAQ,CAAC/F,EAAmBgG,KACnB,CAAEnB,QAAS7E,EAAMiG,SAASC,eAAeF,EAAS5B,OAAOG,YADlEwB,CAEGzB,IAGQ6B,GAAgBvC,EAAAA,EAAAA,GAAkB/E,EAAAA,EAAWC,eAAeI,aAAc4G,GAEvF,W","sources":["common/utils/ErrorUtils.tsx","../node_modules/react-error-boundary/dist/react-error-boundary.esm.js","common/utils/withErrorBoundary.tsx","common/utils/withRouterNext.tsx","experiment-tracking/components/DirectRunPage.tsx"],"sourcesContent":["import React from 'react';\n\nclass ErrorUtils {\n  static mlflowServices = {\n    MODEL_REGISTRY: 'Model Registry',\n    EXPERIMENTS: 'Experiments',\n    MODEL_SERVING: 'Model Serving',\n    RUN_TRACKING: 'Run Tracking',\n  };\n}\n\nexport default ErrorUtils;\n","'use client';\nimport { createContext, Component, createElement, isValidElement, useContext, useState, useMemo, forwardRef } from 'react';\n\nconst ErrorBoundaryContext = createContext(null);\n\nconst initialState = {\n  didCatch: false,\n  error: null\n};\nclass ErrorBoundary extends Component {\n  constructor(props) {\n    super(props);\n    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);\n    this.state = initialState;\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      didCatch: true,\n      error\n    };\n  }\n  resetErrorBoundary() {\n    const {\n      error\n    } = this.state;\n    if (error !== null) {\n      var _this$props$onReset, _this$props;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {\n        args,\n        reason: \"imperative-api\"\n      });\n      this.setState(initialState);\n    }\n  }\n  componentDidCatch(error, info) {\n    var _this$props$onError, _this$props2;\n    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);\n  }\n  componentDidUpdate(prevProps, prevState) {\n    const {\n      didCatch\n    } = this.state;\n    const {\n      resetKeys\n    } = this.props;\n\n    // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,\n    // we'd end up resetting the error boundary immediately.\n    // This would likely trigger a second error to be thrown.\n    // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.\n\n    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {\n      var _this$props$onReset2, _this$props3;\n      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {\n        next: resetKeys,\n        prev: prevProps.resetKeys,\n        reason: \"keys\"\n      });\n      this.setState(initialState);\n    }\n  }\n  render() {\n    const {\n      children,\n      fallbackRender,\n      FallbackComponent,\n      fallback\n    } = this.props;\n    const {\n      didCatch,\n      error\n    } = this.state;\n    let childToRender = children;\n    if (didCatch) {\n      const props = {\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      };\n      if (typeof fallbackRender === \"function\") {\n        childToRender = fallbackRender(props);\n      } else if (FallbackComponent) {\n        childToRender = createElement(FallbackComponent, props);\n      } else if (fallback === null || isValidElement(fallback)) {\n        childToRender = fallback;\n      } else {\n        throw error;\n      }\n    }\n    return createElement(ErrorBoundaryContext.Provider, {\n      value: {\n        didCatch,\n        error,\n        resetErrorBoundary: this.resetErrorBoundary\n      }\n    }, childToRender);\n  }\n}\nfunction hasArrayChanged() {\n  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));\n}\n\nfunction assertErrorBoundaryContext(value) {\n  if (value == null || typeof value.didCatch !== \"boolean\" || typeof value.resetErrorBoundary !== \"function\") {\n    throw new Error(\"ErrorBoundaryContext not found\");\n  }\n}\n\nfunction useErrorBoundary() {\n  const context = useContext(ErrorBoundaryContext);\n  assertErrorBoundaryContext(context);\n  const [state, setState] = useState({\n    error: null,\n    hasError: false\n  });\n  const memoized = useMemo(() => ({\n    resetBoundary: () => {\n      context.resetErrorBoundary();\n      setState({\n        error: null,\n        hasError: false\n      });\n    },\n    showBoundary: error => setState({\n      error,\n      hasError: true\n    })\n  }), [context.resetErrorBoundary]);\n  if (state.hasError) {\n    throw state.error;\n  }\n  return memoized;\n}\n\nfunction withErrorBoundary(component, errorBoundaryProps) {\n  const Wrapped = forwardRef((props, ref) => createElement(ErrorBoundary, errorBoundaryProps, createElement(component, {\n    ...props,\n    ref\n  })));\n\n  // Format for display in DevTools\n  const name = component.displayName || component.name || \"Unknown\";\n  Wrapped.displayName = \"withErrorBoundary(\".concat(name, \")\");\n  return Wrapped;\n}\n\nexport { ErrorBoundary, ErrorBoundaryContext, useErrorBoundary, withErrorBoundary };\n","import React from 'react';\nimport { ErrorBoundary } from 'react-error-boundary';\nimport ErrorUtils from './ErrorUtils';\nimport { DangerIcon, Empty } from '@databricks/design-system';\nimport { FormattedMessage } from 'react-intl';\n\nexport type ErrorBoundaryProps = {\n  children: React.Component;\n};\n\nfunction ErrorFallback() {\n  return (\n    <Empty\n      data-testid=\"fallback\"\n      title={<FormattedMessage defaultMessage=\"Error\" description=\"Title of editor error fallback component\" />}\n      description={\n        <FormattedMessage\n          defaultMessage=\"An error occurred while rendering this component.\"\n          description=\"Description of error fallback component\"\n        />\n      }\n      image={<DangerIcon />}\n    />\n  );\n}\n\nexport function CustomErrorBoundary({ children }: React.PropsWithChildren<ErrorBoundaryProps>) {\n  function logErrorToConsole(error: Error, info: { componentStack: string }) {\n    console.error('Caught Unexpected Error: ', error, info.componentStack);\n  }\n\n  return (\n    <ErrorBoundary onError={logErrorToConsole} fallback={<ErrorFallback />}>\n      {children}\n    </ErrorBoundary>\n  );\n}\n\nexport function withErrorBoundary<P>(\n  service: string,\n  Component: React.ComponentType<P>,\n  errorMessage?: React.ReactNode,\n): React.ComponentType<P> {\n  return function CustomErrorBoundaryWrapper(props: P) {\n    return (\n      <CustomErrorBoundary>\n        {/* @ts-expect-error Generics don't play well with WithConditionalCSSProp type coming @emotion/react jsx typing to validate css= prop values typing. More details here: emotion-js/emotion#2169 */}\n        <Component {...props} />\n      </CustomErrorBoundary>\n    );\n  };\n}\n","import React from 'react';\n\nimport {\n  type Location,\n  type Params as RouterDOMParams,\n  type NavigateOptions,\n  type To,\n  useLocation,\n  useNavigate,\n  useParams,\n} from '../../common/utils/RoutingUtils';\n\nexport interface WithRouterNextProps<Params extends RouterDOMParams = RouterDOMParams> {\n  navigate: ReturnType<typeof useNavigate>;\n  location: Location;\n  params: Params;\n}\n\n/**\n * This HoC serves as a retrofit for class components enabling them to use\n * react-router v6's location, navigate and params being injected via props.\n */\nexport const withRouterNext =\n  <Props, Params extends RouterDOMParams>(Component: React.ComponentType<Props & WithRouterNextProps<Params>>) =>\n  (\n    props: Omit<\n      Props,\n      | 'location'\n      | 'navigate'\n      | 'params'\n      | 'navigationType'\n      /* prettier-ignore*/\n    >,\n  ) => {\n    const location = useLocation();\n    const navigate = useNavigate();\n    const params = useParams<Params>();\n\n    return (\n      <Component\n        /* prettier-ignore */\n        params={params as Params}\n        location={location}\n        navigate={navigate}\n        {...(props as Props)}\n      />\n    );\n  };\n","import { PageWrapper, LegacySkeleton } from '@databricks/design-system';\nimport { useEffect, useState } from 'react';\nimport { connect, useDispatch } from 'react-redux';\nimport { useParams, useNavigate } from '../../common/utils/RoutingUtils';\nimport { ErrorWrapper } from '../../common/utils/ErrorWrapper';\nimport Utils from '../../common/utils/Utils';\nimport { ReduxState } from '../../redux-types';\nimport { getRunApi } from '../actions';\nimport Routes from '../routes';\nimport { PageNotFoundView } from '../../common/components/PageNotFoundView';\nimport { WithRouterNextProps, withRouterNext } from '../../common/utils/withRouterNext';\nimport { withErrorBoundary } from '../../common/utils/withErrorBoundary';\nimport ErrorUtils from '../../common/utils/ErrorUtils';\n\nexport const DirectRunPageImpl = (props: any) => {\n  const { runUuid } = useParams<{ runUuid: string }>();\n  const [error, setError] = useState<ErrorWrapper>();\n  const navigate = useNavigate();\n\n  const dispatch = useDispatch();\n\n  // Reset error after changing requested run\n  useEffect(() => {\n    setError(undefined);\n  }, [runUuid]);\n\n  useEffect(() => {\n    // Start fetching run info if it doesn't exist in the store yet\n    if (!props.runInfo && runUuid) {\n      const action = getRunApi(runUuid);\n      action.payload.catch((e) => {\n        Utils.logErrorAndNotifyUser(e);\n        setError(e);\n      });\n      dispatch(action);\n    }\n  }, [dispatch, runUuid, props.runInfo]);\n\n  useEffect(() => {\n    if (props.runInfo?.experimentId) {\n      navigate(Routes.getRunPageRoute(props.runInfo.experimentId, props.runInfo.runUuid), {\n        replace: true,\n      });\n    }\n  }, [navigate, props.runInfo]);\n\n  // If encountered 404 error, display a proper component\n  if (error?.status === 404) {\n    return <PageNotFoundView />;\n  }\n\n  // If the run is loading, display skeleton\n  return (\n    <PageWrapper>\n      <LegacySkeleton />\n    </PageWrapper>\n  );\n};\n\nconst DirectRunPageWithRouter = withRouterNext(\n  connect((state: ReduxState, ownProps: WithRouterNextProps<{ runUuid: string }>) => {\n    return { runInfo: state.entities.runInfosByUuid[ownProps.params.runUuid] };\n  })(DirectRunPageImpl),\n);\n\nexport const DirectRunPage = withErrorBoundary(ErrorUtils.mlflowServices.RUN_TRACKING, DirectRunPageWithRouter);\n\nexport default DirectRunPage;\n"],"names":["ErrorUtils","mlflowServices","MODEL_REGISTRY","EXPERIMENTS","MODEL_SERVING","RUN_TRACKING","ErrorBoundaryContext","createContext","initialState","didCatch","error","ErrorBoundary","Component","constructor","props","super","this","resetErrorBoundary","bind","state","getDerivedStateFromError","_this$props$onReset","_this$props","_len","arguments","length","args","Array","_key","onReset","call","reason","setState","componentDidCatch","info","_this$props$onError","_this$props2","onError","componentDidUpdate","prevProps","prevState","resetKeys","_this$props$onReset2","_this$props3","a","undefined","b","some","item","index","Object","is","hasArrayChanged","next","prev","render","children","fallbackRender","FallbackComponent","fallback","childToRender","createElement","isValidElement","Provider","value","ErrorFallback","_jsx","Empty","title","FormattedMessage","id","defaultMessage","description","image","DangerIcon","CustomErrorBoundary","_ref","console","componentStack","withErrorBoundary","service","errorMessage","withRouterNext","location","useLocation","navigate","useNavigate","params","useParams","DirectRunPageImpl","runUuid","setError","useState","dispatch","useDispatch","useEffect","runInfo","action","getRunApi","payload","catch","e","Utils","logErrorAndNotifyUser","_props$runInfo","experimentId","Routes","getRunPageRoute","replace","status","PageNotFoundView","PageWrapper","LegacySkeleton","DirectRunPageWithRouter","connect","ownProps","entities","runInfosByUuid","DirectRunPage"],"sourceRoot":""}